# 时间复杂度 关键点

地址：[关于时间复杂度，你不知道的都在这里！](https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html)

---

- 什么是时间复杂度，是用来干嘛的？
- 数据规模对时间复杂度的影响
- 大O的定义
- log究竟以谁为底
- 如何简化复杂的时间复杂度



## 究竟什么是时间复杂度？

时间复杂度是一个函数，它定性描述该算法的运行时间



默认CPU的每个单元运行消耗的时间都是相同的。

假设算法的问题规模为`n`，那么操作单元数量便用函数`f(n)`来表示，随着数据规模`n`的增大，算法执行时间的增长率和`f(n)`的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 **==O(f(n))==**

---



## 什么是大O？

> 算法导论中给出解释：**大O用来表示上界**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界

例如：插入排序的时间复杂度为 O(n^2)

但是

快速排序的时间复杂度是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，**所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)**

**但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，==这里说的O代表的就是一般情况，而不是严格的上界==**

![时间复杂度4，一般情况下的时间复杂度](https://code-thinking-1253855093.file.myqcloud.com/pics/20200728185745611-20230310123844306.png)

**面试中说道算法的时间复杂度是多少指的都是一般情况**

但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着**==数据用例的不一样，时间复杂度也是不同的==**，这一点是一定要注意的

---



## 不同数据规模的差异

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200728191447384-20230310124015324.png" alt="时间复杂度，不同数据规模的差异" style="zoom:67%;" />

在决定使用哪些算法的时候，**不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等）**

**要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）**



**所以我们说的时间复杂度都是==省略常数项系数的，是因为一般情况下都是默认数据规模足够的大==，基于这样的事实，给出的算法时间复杂的的一个排行如下所示**：

O(1)常数阶  <  O(logn)对数阶  <  O(n)线性阶  <  O(nlogn)线性对数阶  <  O(n^2)平方阶  <  O(n^3)立方阶  <  O(2^n)指数阶



**但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。**

---



## 复杂表达式的化简

有时候我们去计算时间复杂度的时候发现不是一个简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，例如：

```text
O(2*n^2 + 10*n + 1000)
```

那这里如何描述这个算法的时间复杂度呢，一种方法就是简化法。

- 去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）

  ```
  O(2*n^2 + 10*n)
  ```

- 去掉**常数系数**（上文中已经详细讲过为什么可以去掉常数项的原因：默认规模非常大）

  ```
  O(n^2 + n)
  ```

- 只保留保留最高项，去掉数量级小一级的n （因为n^2 的数据规模远大于n），最终简化为：

  ```
  O(n^2)
  ```

  如果这一步理解有困难，那也可以做提取n的操作，变成**O(n(n+1))** ，**省略加法常数项后**也就别变成了：

  ```
  O(n^2)
  ```

所以说：这个算法的算法时间复杂度是O(n^2) 

也可以用另一种简化的思路，其实当n大于40的时候， 这个复杂度会**==恒小于O(3 × n^2)==**， O(2 × n^2 + 10 × n + 1000) < O(3 × n^2) ，所以说**最后省略掉常数项系数**最终时间复杂度也是O(n^2)

---



## O(logn)中的log是以什么为底？

平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？

其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，**但我们统一说 logn，也就是忽略底数的描述**

为什么可以这么做呢？如下图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200728191447349-20230310124032001.png" alt="时间复杂度1.png" style="zoom:67%;" />

假如有两个算法的时间复杂度，分别是 log以2为底n的对数 和 log以10为底n的对数 ，那么应该不难理解

 **`以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数`**

而  **以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的**

抽象一下就是在时间复杂度的计算过程中，**==log以 i 为底 n 的对数等于 log 以 j 为底 n 的对数，所以忽略了 i ，直接说是 logn==**

这样就应该不难理解为什么忽略底数了

---



## 举例：

题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。

如果是暴力枚举的话，时间复杂度是多少呢，是O(n^2)么？

这里一些同学**会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单**

除了n^2 次的遍历次数外，**字符串比较依然要消耗m次操作（m也就是字母串的长度）**，所以时间复杂度是O(m × n × n)。

接下来再想一下其他解题思路。

先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。

那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。

之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。

我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。

最后**很明显O(m × n × logn) 要优于O(m × n × n)！**

所以先把字符串集合排序再遍历一遍找到两个相同字符串的方法要比直接暴力枚举的方式更快。

这就是我们通过分析两种算法的时间复杂度得来的。

**当然这不是这道题目的最优解，我仅仅是用这道题目来讲解一下时间复杂度**。