# 0.3 递归算法的时间复杂度

代码随想录 讲解网址：[递归算法的时间复杂度](https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)

## 面试题：求x的n次方



### 最简单的是：一个for循环求出结果

```cpp
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

时间复杂度：O(n)





此时面试官会说，有没有效率更好的算法呢。

**如果此时没有思路，不要说：我不会，我不知道了等等**。

可以和面试官探讨一下，询问：“可不可以给点提示”。面试官提示：“考虑一下递归算法”。

### 递归算法

```cpp
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```



#### 递归算法的时间复杂度本质上是要看：**递归的次数 \* 每次递归中的操作次数**

上面的代码的时间复杂度如下：

每次n-1，**递归了n次**，时间复杂度是O(n)，**每次进行了一个乘法操作**，乘法操作的时间复杂度一个常数项**O(1)**，所以这份代码的时间复杂度是 **n × 1 = O(n)**

这个时间复杂度就没有达到面试官的预期。于是又写出了如下的递归算法的代码：

```cpp
int function3(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;

    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

面试官看到后微微一笑，问：“这份代码的时间复杂度又是多少呢？” 此刻有些同学可能要陷入了沉思了。

我们来分析一下，首先看递归了多少次呢，可以把递归抽象出一棵满二叉树。刚刚同学写的这个算法，可以用一棵满二叉树来表示（为了方便表示，选择n为偶数16），如图：

![递归算法的时间复杂度](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209193909426.png)

当前这棵二叉树就是求x的n次方，n为16的情况，n为16的时候，进行了多少次乘法运算呢？

这棵树上**<u>每一个节点就代表着一次递归并进行了一次相乘操作，所以进行了多少次递归的话，就是看这棵树上有多少个节点</u>**

熟悉二叉树话应该知道如何求满二叉树节点数量，这棵满二叉树的节点数量就是`2^3 + 2^2 + 2^1 + 2^0 = 15`，可以发现：<u>**这其实是等比数列的求和公式，这个结论在二叉树相关的面试题里也经常出现**</u>

这么如果是求x的n次方，这个递归树有多少个节点呢，如下图所示：(m为深度，从0开始)

![递归求时间复杂度](https://code-thinking-1253855093.file.myqcloud.com/pics/20200728195531892.png)

**时间复杂度忽略掉常数项`-1`之后，这个递归算法的时间复杂度依然是O(n)**。对，你没看错，依然是O(n)的时间复杂度！



### 那么O(logn)的递归算法应该怎么写呢？

想一想刚刚给出的那份递归算法的代码，是不是有哪里比较冗余呢，其实有重复计算的部分。

```cpp
int function4(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;		// 如果t是奇数，例如为7：7/2==3 这里的运算就是 2^3 * 2^3 * 2 == 2^7
    }
    return t * t;				// 如果t是偶数，例如为8：8/2==4 这里的运算就是 2^4 * 2^4 == 2^8
}
```

依然还是看他递归了多少次，可以看到这里仅**仅有一个递归调用，且每次都是n/2** ，所以这里我们**一共调用了log以2为底n的对数次**

**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**



## 总结

**一道非常简单的面试题目：求x的n次方，来逐步分析递归算法的时间复杂度，注意不要一看到递归就想到了O(logn)！**

同样使用递归，有的同学可以写出O(logn)的代码，有的同学还可以写出O(n)的代码。

对于function3 这样的递归实现，很容易让人感觉这是O(log n)的时间复杂度，其实这是O(n)的算法！

```cpp
int function3(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

可以看出这道题目非常简单，但是又很考究算法的功底，特别是对递归的理解

大厂面试的时候最喜欢用“简单题”来考察候选人的算法功底，注意这里的“简单题”可并不一定真的简单哦！

同一道题目，同样是递归，效率可是不一样的！